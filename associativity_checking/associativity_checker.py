# Usage:
# Receives a table of n numbers. Each entry is a number between 0 and n-1.

import numpy as np
import sys
from collections import deque

S_SIZE = 7

class AssociativityChecker:
    def __init__(self, A, n):
        self.A = A
        self.n = n

    # linear extension of the operation
    def op(s, u, v):
        w = np.zeros(s.n, dtype=np.int)
        for x in range(s.n):
            for y in range(s.n):
                exy = s.A[x,y]
                w[exy] += u[x]*v[y]
                w[exy] %= S_SIZE
        return w

    def is_associative_random(s,t):
        for _ in range(t):
            # random vectors with entries in the finite field Z/Z_{S_SIZE}*
            u = np.random.randint(1, S_SIZE+1, size=s.n)
            v = np.random.randint(1, S_SIZE+1, size=s.n)
            w = np.random.randint(1, S_SIZE+1, size=s.n)
            is_it = (s.op(s.op(u,v), w) == s.op(u, s.op(v,w))).all()
            if (not is_it): return False
        return True

    def is_cancellative(s):
        for x in range(s.n):
            xs = np.zeros(s.n, dtype=bool)
            for y in range(s.n):
                xs[s.A[x,y]] = True
            if (not xs.all()): return False
        return True

    # we use deque as a linked list
    def generators(s):
        # set of generators
        gen = []
        # inlist: elements in the set generated by gen
        inlist = []
        is_inlist = np.zeros(s.n, dtype=bool)
        # outlist: elements out of the set generated by gen
        outlist = deque(range(0,s.n))

        while len(outlist) != 0:
            x = outlist.popleft()
            while is_inlist[x] and len(outlist):
                x = outlist.popleft()
            if (is_inlist[x]): break
            gen.append(x)

            new_elements = deque([x])
            while (len(new_elements) != 0):
                x = new_elements.popleft()
                if (is_inlist[x]): continue
                inlist.append(x)
                is_inlist[x] = True
                for y in inlist:
                    if (not is_inlist[s.A[x,y]]):
                        new_elements.append(s.A[x,y])
                    if (not is_inlist[s.A[y,x]]):
                        new_elements.append(s.A[y,x])
        return gen

    # True if the operation is associative when it is cancellative
    def is_associative_deterministic(s):
        gs = s.generators()
        for x in range(s.n):
            for y in range(s.n):
                for g in gs:
                    if (s.A[s.A[x,g],y] != s.A[x,s.A[g,y]]):
                        return False
        return True
